#ifndef GEOMETRY_CONTACTS_OBB_SPHERE_H
#define GEOMETRY_CONTACTS_OBB_SPHERE_H

#include <types/geometry_obb.h>
#include <types/geometry_sphere.h>
#include <contacts/geometry_contacts_callback.h>

namespace geometry
{

  /**
   * OBB Sphere Contact Point Generation
   *
   * @param A                 The OBB box.
   * @param B                 The sphere.
   * @param envelope          The size of the collision envelope.
   * @param callback          A pointer to a callback interface which is used to add contact point information
   * @param flip              Set this to true when using this method to test sphere versus box (ie when order of objects are swapped)
   *
   */
  template<typename MT>
  inline void contacts_obb_sphere(
                                 OBB<MT> const & A
                                 , Sphere<typename MT::vector3_type> const & B
                                 , typename MT::real_type const & envelope
                                 , ContactsCallback<typename MT::vector3_type> & callback
                                 , bool const flip = false
                                 )
  {
    typedef typename MT::real_type         T;
    typedef typename MT::vector3_type      V;
    typedef typename MT::quaternion_type   Q;
    typedef typename MT::value_traits      VT;
    typedef typename MT::coordsys_type     C;

    using std::sqrt;

    T const & radius = B.radius();
    V const & ext    = A.half_extent();

    V const & pA     = A.center();
    V const & pB     = B.center();
    Q const & qA     = A.orientation();
    Q const   qB     = Q::identity();

    C const AtoWCS   = C::make(pA,qA);
    C const BtoWCS   = C::make(pB,qB);

    //--- Transform sphere center into model frame of box
    C const BtoA = tiny::model_update(BtoWCS,AtoWCS);
    V const c    = BtoA.T();

    //--- Cut line from center of box to center of sphere by the box
    //--- faces. This is done in the model frame of the box.
    bool inside = true;

    V p = c;
    V n = V::zero();
    T d = VT::zero();

    if(c(0) > ext(0))
    {
      p(0) = ext(0);
      n(0) = VT::one();
      inside = false;
    }
    if(c(0) < -ext(0))
    {
      p(0) = -ext(0);
      n(0) = -VT::one();
      inside = false;
    }
    if(c(1) > ext(1))
    {
      p(1) = ext(1);
      n(1) = VT::one();
      inside = false;
    }
    if(c(1) < -ext(1))
    {
      p(1) = -ext(1);
      n(1) = -VT::one();
      inside = false;
    }
    if(c(2) > ext(2))
    {
      p(2) = ext(2);
      n(2) = VT::one();
      inside = false;
    }
    if(c(2) < -ext(2))
    {
      p(2) = -ext(2);
      n(2) = -VT::one();
      inside = false;
    }

    //--- This is the center-line did intersect the box faces or
    //--- if the sphere center lies inside the box.
    if(inside)
    {
      //--- We search for the face of the box closest to the center of the sphere.
      //---
      //--- We then set the contact point equal to the deepst point of the sphere (in
      //--- direction of the normal), and the contact normal equal to the normal of
      //--- the closest box face.
      //---
      //--- Penetration depth is simply the distance between the sphere and the
      //--- closest face plus the radius of the sphere.
      int cnt_closest_faces = 0;

      p.clear();
      V f = ext - tiny::abs( c );

      if(f(0) <= f(1) && f(0) <= f(2))
      {
        d = -f(0) - radius;
        n(0) = (c(0) > 0)? VT::one() : -VT::one();
        ++cnt_closest_faces;
        p(0) = (c(0) > 0)?ext(0):-ext(0);
      }
      if(f(1) <= f(0) && f(1) <= f(2))
      {
        d = -f(1) - radius;
        n(1) = (c(1) > 0) ? VT::one() : -VT::one();
        ++cnt_closest_faces;
        p(1) = (c(1) > 0) ? ext(1) : -ext(1);
      }
      if(f(2) <= f(0) && f(2) <= f(1))
      {
        d = -f(2) - radius;
        n(2) = (c(2) >0)?1:-1;
        ++cnt_closest_faces;
        p(2) = (c(2) > 0)?ext(2):-ext(2);
      }
      if(cnt_closest_faces>1)//--- more than one closest face?
      {
        n = unit(n);
        f = p-c; //--- reuse f
        d = - sqrt(f*f) - radius;
      }
      //p = c - n*r; //--- point on sphere
      p = c - n*(d+radius); //--- point on box
    }
    else
    {
      //--- Sphere center was outside box, contact is generated by using the
      //--- intersection point at as contact point, and contact normal is set
      //--- equal to the normal of the box at the intersection point.
      //--- Separation (or penetration) distance is equal to the distance
      //--- between the intersection point and the sphere center (projected
      //--- onto the contact normal) minus the sphere radius.
      T tmp = sqrt(n*n);
      n /= tmp;
      V diff = c - p;
      //--- Bug-reported by Stefan Glimberg!!!
      //distance = diff*n - r;
      d = sqrt(diff*diff) - radius;
    }
    if( d <=  envelope )
    {
      //--- Transform normal and point into WCS
      p = tiny::xform_point(AtoWCS,p);
      n = flip ? -tiny::xform_vector(AtoWCS, n) : tiny::xform_vector(AtoWCS, n);
      callback(p,n,d);
    }

  }
}//namespace geometry

//GEOMETRY_CONTACTS_OBB_SPHERE_H
#endif